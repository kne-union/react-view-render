{"ast":null,"code":"/**\n * Copyright (c) 2014-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule BaseEventEmitter\n * @typechecks\n */\n'use strict';\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError('Cannot call a class as a function');\n  }\n}\n\nvar EmitterSubscription = require('./EmitterSubscription');\n\nvar EventSubscriptionVendor = require('./EventSubscriptionVendor');\n\nvar emptyFunction = require('fbjs/lib/emptyFunction');\n\nvar invariant = require('fbjs/lib/invariant');\n/**\n * @class BaseEventEmitter\n * @description\n * An EventEmitter is responsible for managing a set of listeners and publishing\n * events to them when it is told that such events happened. In addition to the\n * data for the given event it also sends a event control object which allows\n * the listeners/handlers to prevent the default behavior of the given event.\n *\n * The emitter is designed to be generic enough to support all the different\n * contexts in which one might want to emit events. It is a simple multicast\n * mechanism on top of which extra functionality can be composed. For example, a\n * more advanced emitter may use an EventHolder and EventFactory.\n */\n\n\nvar BaseEventEmitter = function () {\n  /**\n   * @constructor\n   */\n  function BaseEventEmitter() {\n    _classCallCheck(this, BaseEventEmitter);\n\n    this._subscriber = new EventSubscriptionVendor();\n    this._currentSubscription = null;\n  }\n  /**\n   * Adds a listener to be invoked when events of the specified type are\n   * emitted. An optional calling context may be provided. The data arguments\n   * emitted will be passed to the listener function.\n   *\n   * TODO: Annotate the listener arg's type. This is tricky because listeners\n   *       can be invoked with varargs.\n   *\n   * @param {string} eventType - Name of the event to listen to\n   * @param {function} listener - Function to invoke when the specified event is\n   *   emitted\n   * @param {*} context - Optional context object to use when invoking the\n   *   listener\n   */\n\n\n  BaseEventEmitter.prototype.addListener = function addListener(eventType, listener, context) {\n    return this._subscriber.addSubscription(eventType, new EmitterSubscription(this._subscriber, listener, context));\n  };\n  /**\n   * Similar to addListener, except that the listener is removed after it is\n   * invoked once.\n   *\n   * @param {string} eventType - Name of the event to listen to\n   * @param {function} listener - Function to invoke only once when the\n   *   specified event is emitted\n   * @param {*} context - Optional context object to use when invoking the\n   *   listener\n   */\n\n\n  BaseEventEmitter.prototype.once = function once(eventType, listener, context) {\n    var emitter = this;\n    return this.addListener(eventType, function () {\n      emitter.removeCurrentListener();\n      listener.apply(context, arguments);\n    });\n  };\n  /**\n   * Removes all of the registered listeners, including those registered as\n   * listener maps.\n   *\n   * @param {?string} eventType - Optional name of the event whose registered\n   *   listeners to remove\n   */\n\n\n  BaseEventEmitter.prototype.removeAllListeners = function removeAllListeners(eventType) {\n    this._subscriber.removeAllSubscriptions(eventType);\n  };\n  /**\n   * Provides an API that can be called during an eventing cycle to remove the\n   * last listener that was invoked. This allows a developer to provide an event\n   * object that can remove the listener (or listener map) during the\n   * invocation.\n   *\n   * If it is called when not inside of an emitting cycle it will throw.\n   *\n   * @throws {Error} When called not during an eventing cycle\n   *\n   * @example\n   *   var subscription = emitter.addListenerMap({\n   *     someEvent: function(data, event) {\n   *       console.log(data);\n   *       emitter.removeCurrentListener();\n   *     }\n   *   });\n   *\n   *   emitter.emit('someEvent', 'abc'); // logs 'abc'\n   *   emitter.emit('someEvent', 'def'); // does not log anything\n   */\n\n\n  BaseEventEmitter.prototype.removeCurrentListener = function removeCurrentListener() {\n    !!!this._currentSubscription ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Not in an emitting cycle; there is no current subscription') : invariant(false) : undefined;\n\n    this._subscriber.removeSubscription(this._currentSubscription);\n  };\n  /**\n   * Returns an array of listeners that are currently registered for the given\n   * event.\n   *\n   * @param {string} eventType - Name of the event to query\n   * @return {array}\n   */\n\n\n  BaseEventEmitter.prototype.listeners = function listeners(eventType)\n  /* TODO: Array<EventSubscription> */\n  {\n    var subscriptions = this._subscriber.getSubscriptionsForType(eventType);\n\n    return subscriptions ? subscriptions.filter(emptyFunction.thatReturnsTrue).map(function (subscription) {\n      return subscription.listener;\n    }) : [];\n  };\n  /**\n   * Emits an event of the given type with the given data. All handlers of that\n   * particular type will be notified.\n   *\n   * @param {string} eventType - Name of the event to emit\n   * @param {*} Arbitrary arguments to be passed to each registered listener\n   *\n   * @example\n   *   emitter.addListener('someEvent', function(message) {\n   *     console.log(message);\n   *   });\n   *\n   *   emitter.emit('someEvent', 'abc'); // logs 'abc'\n   */\n\n\n  BaseEventEmitter.prototype.emit = function emit(eventType) {\n    var subscriptions = this._subscriber.getSubscriptionsForType(eventType);\n\n    if (subscriptions) {\n      var keys = Object.keys(subscriptions);\n\n      for (var ii = 0; ii < keys.length; ii++) {\n        var key = keys[ii];\n        var subscription = subscriptions[key]; // The subscription may have been removed during this event loop.\n\n        if (subscription) {\n          this._currentSubscription = subscription;\n\n          this.__emitToSubscription.apply(this, [subscription].concat(Array.prototype.slice.call(arguments)));\n        }\n      }\n\n      this._currentSubscription = null;\n    }\n  };\n  /**\n   * Provides a hook to override how the emitter emits an event to a specific\n   * subscription. This allows you to set up logging and error boundaries\n   * specific to your environment.\n   *\n   * @param {EmitterSubscription} subscription\n   * @param {string} eventType\n   * @param {*} Arbitrary arguments to be passed to each registered listener\n   */\n\n\n  BaseEventEmitter.prototype.__emitToSubscription = function __emitToSubscription(subscription, eventType) {\n    var args = Array.prototype.slice.call(arguments, 2);\n    subscription.listener.apply(subscription.context, args);\n  };\n\n  return BaseEventEmitter;\n}();\n\nmodule.exports = BaseEventEmitter;","map":{"version":3,"sources":["/Users/linzhipeng/Documents/code_cloud/@kne/react-view-render/node_modules/fbemitter/lib/BaseEventEmitter.js"],"names":["_classCallCheck","instance","Constructor","TypeError","EmitterSubscription","require","EventSubscriptionVendor","emptyFunction","invariant","BaseEventEmitter","_subscriber","_currentSubscription","prototype","addListener","eventType","listener","context","addSubscription","once","emitter","removeCurrentListener","apply","arguments","removeAllListeners","removeAllSubscriptions","process","env","NODE_ENV","undefined","removeSubscription","listeners","subscriptions","getSubscriptionsForType","filter","thatReturnsTrue","map","subscription","emit","keys","Object","ii","length","key","__emitToSubscription","concat","Array","slice","call","args","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2014-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule BaseEventEmitter\n * @typechecks\n */\n\n'use strict';\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nvar EmitterSubscription = require('./EmitterSubscription');\nvar EventSubscriptionVendor = require('./EventSubscriptionVendor');\n\nvar emptyFunction = require('fbjs/lib/emptyFunction');\nvar invariant = require('fbjs/lib/invariant');\n\n/**\n * @class BaseEventEmitter\n * @description\n * An EventEmitter is responsible for managing a set of listeners and publishing\n * events to them when it is told that such events happened. In addition to the\n * data for the given event it also sends a event control object which allows\n * the listeners/handlers to prevent the default behavior of the given event.\n *\n * The emitter is designed to be generic enough to support all the different\n * contexts in which one might want to emit events. It is a simple multicast\n * mechanism on top of which extra functionality can be composed. For example, a\n * more advanced emitter may use an EventHolder and EventFactory.\n */\n\nvar BaseEventEmitter = (function () {\n  /**\n   * @constructor\n   */\n\n  function BaseEventEmitter() {\n    _classCallCheck(this, BaseEventEmitter);\n\n    this._subscriber = new EventSubscriptionVendor();\n    this._currentSubscription = null;\n  }\n\n  /**\n   * Adds a listener to be invoked when events of the specified type are\n   * emitted. An optional calling context may be provided. The data arguments\n   * emitted will be passed to the listener function.\n   *\n   * TODO: Annotate the listener arg's type. This is tricky because listeners\n   *       can be invoked with varargs.\n   *\n   * @param {string} eventType - Name of the event to listen to\n   * @param {function} listener - Function to invoke when the specified event is\n   *   emitted\n   * @param {*} context - Optional context object to use when invoking the\n   *   listener\n   */\n\n  BaseEventEmitter.prototype.addListener = function addListener(eventType, listener, context) {\n    return this._subscriber.addSubscription(eventType, new EmitterSubscription(this._subscriber, listener, context));\n  };\n\n  /**\n   * Similar to addListener, except that the listener is removed after it is\n   * invoked once.\n   *\n   * @param {string} eventType - Name of the event to listen to\n   * @param {function} listener - Function to invoke only once when the\n   *   specified event is emitted\n   * @param {*} context - Optional context object to use when invoking the\n   *   listener\n   */\n\n  BaseEventEmitter.prototype.once = function once(eventType, listener, context) {\n    var emitter = this;\n    return this.addListener(eventType, function () {\n      emitter.removeCurrentListener();\n      listener.apply(context, arguments);\n    });\n  };\n\n  /**\n   * Removes all of the registered listeners, including those registered as\n   * listener maps.\n   *\n   * @param {?string} eventType - Optional name of the event whose registered\n   *   listeners to remove\n   */\n\n  BaseEventEmitter.prototype.removeAllListeners = function removeAllListeners(eventType) {\n    this._subscriber.removeAllSubscriptions(eventType);\n  };\n\n  /**\n   * Provides an API that can be called during an eventing cycle to remove the\n   * last listener that was invoked. This allows a developer to provide an event\n   * object that can remove the listener (or listener map) during the\n   * invocation.\n   *\n   * If it is called when not inside of an emitting cycle it will throw.\n   *\n   * @throws {Error} When called not during an eventing cycle\n   *\n   * @example\n   *   var subscription = emitter.addListenerMap({\n   *     someEvent: function(data, event) {\n   *       console.log(data);\n   *       emitter.removeCurrentListener();\n   *     }\n   *   });\n   *\n   *   emitter.emit('someEvent', 'abc'); // logs 'abc'\n   *   emitter.emit('someEvent', 'def'); // does not log anything\n   */\n\n  BaseEventEmitter.prototype.removeCurrentListener = function removeCurrentListener() {\n    !!!this._currentSubscription ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Not in an emitting cycle; there is no current subscription') : invariant(false) : undefined;\n    this._subscriber.removeSubscription(this._currentSubscription);\n  };\n\n  /**\n   * Returns an array of listeners that are currently registered for the given\n   * event.\n   *\n   * @param {string} eventType - Name of the event to query\n   * @return {array}\n   */\n\n  BaseEventEmitter.prototype.listeners = function listeners(eventType) /* TODO: Array<EventSubscription> */{\n    var subscriptions = this._subscriber.getSubscriptionsForType(eventType);\n    return subscriptions ? subscriptions.filter(emptyFunction.thatReturnsTrue).map(function (subscription) {\n      return subscription.listener;\n    }) : [];\n  };\n\n  /**\n   * Emits an event of the given type with the given data. All handlers of that\n   * particular type will be notified.\n   *\n   * @param {string} eventType - Name of the event to emit\n   * @param {*} Arbitrary arguments to be passed to each registered listener\n   *\n   * @example\n   *   emitter.addListener('someEvent', function(message) {\n   *     console.log(message);\n   *   });\n   *\n   *   emitter.emit('someEvent', 'abc'); // logs 'abc'\n   */\n\n  BaseEventEmitter.prototype.emit = function emit(eventType) {\n    var subscriptions = this._subscriber.getSubscriptionsForType(eventType);\n    if (subscriptions) {\n      var keys = Object.keys(subscriptions);\n      for (var ii = 0; ii < keys.length; ii++) {\n        var key = keys[ii];\n        var subscription = subscriptions[key];\n        // The subscription may have been removed during this event loop.\n        if (subscription) {\n          this._currentSubscription = subscription;\n          this.__emitToSubscription.apply(this, [subscription].concat(Array.prototype.slice.call(arguments)));\n        }\n      }\n      this._currentSubscription = null;\n    }\n  };\n\n  /**\n   * Provides a hook to override how the emitter emits an event to a specific\n   * subscription. This allows you to set up logging and error boundaries\n   * specific to your environment.\n   *\n   * @param {EmitterSubscription} subscription\n   * @param {string} eventType\n   * @param {*} Arbitrary arguments to be passed to each registered listener\n   */\n\n  BaseEventEmitter.prototype.__emitToSubscription = function __emitToSubscription(subscription, eventType) {\n    var args = Array.prototype.slice.call(arguments, 2);\n    subscription.listener.apply(subscription.context, args);\n  };\n\n  return BaseEventEmitter;\n})();\n\nmodule.exports = BaseEventEmitter;"]},"metadata":{},"sourceType":"script"}